
Database API ::::::::::::::::::::::::::::

what need to learn from this all methods :  ( create chagpt chat like REST API helper and find this question)

1. all options of insert 


#############################################################################################################################################################################################



1ï¸âƒ£ frappe.db.get_list
used to fetch a list of records from a particular doctype table. Think of it as a simple SELECT query wrapper in Frappe.

- Automatically applies user permissions, so you only get records the session user can see.
- By default, it returns a list of dicts with field data.
    - If fields is not provided, it returns only the document names.
- You can use pluck to get a single field as a list.
- Aliased as frappe.get_list (both work the same).

Important notes:

- Filters can be simple ({'field': value}), conditional (['field','>','value']), or range (between).
- You can sort (order_by), paginate (start & page_length), or group (group_by).
- Use as_list=True to get tuples instead of dicts.

------------------------------------------------------------------

ğŸ§  Syntax :

frappe.db.get_list(
    doctype,          # name of the DocType
    filters=None,     # dictionary or list for filtering records
    or_filters=None,  # optional OR conditions
    fields=None,      # list of fields to return
    order_by=None,    # string for sorting
    group_by=None,    # string for GROUP BY
    start=0,          # starting index for pagination
    page_length=20,   # number of records to return
    pluck=None,       # single field to return as list
    as_list=False     # return list of tuples instead of dicts
)




#############################################################################################################################################################################################



2ï¸âƒ£ frappe.db.get_all

frappe.db.get_all is very similar to frappe.db.get_list with one key difference:
- It fetches all records from the doctype without checking user permissions.
- This is useful when you need complete data access, regardless of the session userâ€™s roles.
- Aliased as frappe.get_all (both work the same).
- Otherwise, all other features are the same as get_list: filters, fields, order, group_by, pagination, pluck, as_list.

Important notes:
âš ï¸ Because it ignores permissions, use carefully in production!
Filters, sorting, grouping, and plucking work exactly the same as get_list.

--------------------------------------------------------------------

ğŸ§  Syntax :

frappe.db.get_all(
    doctype,          # name of the DocType
    filters=None,     # dictionary or list for filtering records
    or_filters=None,  # optional OR conditions
    fields=None,      # list of fields to return
    order_by=None,    # string for sorting
    group_by=None,    # string for GROUP BY
    start=0,          # starting index for pagination
    page_length=0,    # number of records to return, 0 = all
    pluck=None,       # single field to return as list
    as_list=False     # return list of tuples instead of dicts
)



#############################################################################################################################################################################################

Main Difference: get_list vs get_all

frappe.db.get_list â†’ Returns records respecting user permissions. âœ…
frappe.db.get_all â†’ Returns all records ignoring permissions. âŒ

Both support filters, fields, pluck, order_by, group_by, pagination.


#############################################################################################################################################################################################

3ï¸âƒ£ frappe.db.get_value
used to fetch value(s) of a specific field (or multiple fields) from a document in a doctype.

- Can fetch a single value or multiple values.
- Can fetch using document name or filters.
- Can return result as a tuple/list (default) or as a dictionary (as_dict=1).
- Aliased as frappe.get_value and frappe.db.get_values â€” all work the same.

Important notes:

- When using filters, it returns the first matching record only.
- Very useful for quick lookups instead of fetching the whole document.

--------------------------------------------------------------------

ğŸ§  Syntax

# Using document name
value = frappe.db.get_value(doctype, name, fieldname)

# Using filters
value = frappe.db.get_value(doctype, filters, fieldname)

# Multiple fields
values = frappe.db.get_value(doctype, name, [field1, field2])

# Return as dictionary
values_dict = frappe.db.get_value(doctype, name, [field1, field2], as_dict=1)


##########################################################################################################################################################################################


4ï¸âƒ£ frappe.db.get_single_value

frappe.db.get_single_value is a shortcut to fetch a field value from a Single DocType.

- Single DocTypes are special doctypes that store only one record (like System Settings, Website Settings, etc.).
- Returns the value of the specified field directly.
- Simpler than get_value because you donâ€™t need to specify the name or filters â€” Single DocTypes always have exactly one record.


Important notes:

- Only works on Single DocTypes.
- Use it when you want a quick value from system configuration.




ğŸ§  Syntax

value = frappe.db.get_single_value(doctype, fieldname)

Simple meaning: Give it the Single DocType and field, it returns the value directly.


##########################################################################################################################################################################################



5ï¸âƒ£ frappe.db.set_value
used to update a field (or multiple fields) in a document directly in the database.


- Does not call ORM triggers like validate or on_update. âœ…
- Updates the modified timestamp by default (unless update_modified=False).
- Aliased as frappe.db.update.

Useful for:

- Updating hidden fields
- Quick updates without running the full document lifecycle

--------------------------------------------------------------------

So if you try to call frappe.db.set_value inside a validate event, it will work, but:
- The validate of the target document youâ€™re updating will not run.
- Only the field value will be updated in the DB.
- modified timestamp will be updated by default (unless update_modified=False).

--------------------------------------------------------------------

Important notes:
- âš ï¸ Because it bypasses triggers, use carefully â€” you might skip validations.
- Can update single field or multiple fields at once.



ğŸ§  Syntax :

# Update a single field
frappe.db.set_value(doctype, name, fieldname, value, update_modified=True)

# Update multiple fields
frappe.db.set_value(doctype, name, {field1: value1, field2: value2}, update_modified=True)


##########################################################################################################################################################################################

6ï¸âƒ£ frappe.db.exists
 used to check whether a document exists in a doctype.

- Returns True if a matching document exists, otherwise False.

Can check by:
1. Doctype and document name
2. Doctype and filter dict
3. Filter dict including doctype key

- Very useful for validating records before creating or updating.
- Optional: cache=True to speed up repeated existence checks.


Important notes:
- âš ï¸ Only checks existence, it does not fetch data.
- Returns Boolean (True/False).



ğŸ§  Syntax :

# Using doctype and document name
exists = frappe.db.exists(doctype, name, cache=False)

# Using doctype and filter dictionary
exists = frappe.db.exists(doctype, filters)

# Using filter dictionary including doctype
exists = frappe.db.exists({"doctype": doctype, "field": value})


##########################################################################################################################################################################################

7ï¸âƒ£ frappe.db.count
used to count the number of records in a doctype.

- Returns an integer representing the total matching records.
- You can optionally provide filters to count only specific records.
- Very useful for reports, dashboards, or validations.


Important notes:

- If no filters are provided, it counts all records in the doctype.
- Only returns the count, not the records themselves.


ğŸ§  Syntax :

# Count all records in a doctype
total = frappe.db.count(doctype)

# Count records with filters
total_filtered = frappe.db.count(doctype, filters)


##########################################################################################################################################################################################


8ï¸âƒ£ frappe.db.delete
used to delete records directly from the database table.

- It executes a DELETE SQL query (DML command).
- It can be rolled back if something goes wrong in the same transaction.

- You can delete:
      - Specific records using filters, or
      - Specific records using filters, or


Important Note âš ï¸:

- This method bypasses ORM triggers (validate, on_update, before_delete, etc.).
- So, always use it carefully â€” it directly affects the database.


ğŸ§  Syntax :

frappe.db.delete(doctype, filters=None)
Simple meaning: Give the Doctype name and (optional) filters â€” it deletes all matching records.

- If filters are not given â†’ all records will be deleted! ğŸ˜¨

ğŸ’¡ Tips:

- Safe usage â†’ Always pass filters to avoid deleting everything.
- After deletion, if youâ€™re in a transaction, you can call frappe.db.rollback() to undo.
- This method can also delete from custom/internal tables (like __Test Table). -> frappe.db.delete("__Test Table")



--------------------------------------------------------------------



what is meaning of this : This method can also delete from custom/internal tables (like __Test Table)

- In Frappe, every Doctype is stored in a database table like this - tab<Doctype Name> ex. Customer â†’ tabCustomer, Database API â†’ tabDatabase API

- But sometimes, Frappe also creates or uses internal tables, which are not linked to a specific Doctype, usually for testing, logs, or internal framework usage.
  These internal tables always start with double underscore (__).

ex :
__Test Table
__UserCache
__CustomTable

âœ… Means â†’
frappe.db.delete() can be used not only on normal doctypes but also directly on internal tables (whose names start with __).


âš ï¸ Important Note:

- Internal tables donâ€™t have Doctype logic â†’ so no validation or permission checks.
- Be careful â€” if you delete from an internal table that Frappe relies on, it can cause system issues.




##########################################################################################################################################################################################


9ï¸âƒ£ frappe.db.truncate
used to completely empty a table in the database â€” it deletes all rows instantly.

- It executes a DDL (Data Definition Language) command â†’ TRUNCATE TABLE.
- It is much faster than frappe.db.delete() when you need to remove everything.
- âš ï¸ It cannot be rolled back â€” once executed, data is gone permanently.
- It also triggers a commit automatically before running, ensuring the truncate happens cleanly.


ğŸ§  Syntax :

frappe.db.truncate(doctype)
Simple meaning: Give a doctype name or internal table name â€” it will wipe out all records from that table.


âš ï¸ Important Notes / Danger Zone ğŸš¨

- ğŸ§± TRUNCATE = DDL Command â†’ not reversible, cannot rollback.
- ğŸ§  Runs faster than DELETE because it doesnâ€™t check each row â€” it just resets the whole table.
- ğŸ•’ Use only when you are sure you want to clear all data (e.g., for logs, temporary tables, testing).
- ğŸ”’ Permissions or triggers (like validate, on_update, before_delete) are not applied.


##########################################################################################################################################################################################

diff b/w delete vs truncate :

| Method                 | Type | Rollback Possible  | Affects Each Row  | Speed          | Use Case                |
| :--------------------- | :--- | :----------------  | :---------------  | :-----------   | :---------------------- |
| `frappe.db.delete()`   | DML  | âœ… Yes             | âœ… Yes            | âš¡ Slow        | Delete selected records |
| `frappe.db.truncate()` | DDL  | âŒ No              | âŒ No             | âš¡âš¡ Very Fast | Clear entire table      |


So in short, brother ğŸ‘‡
ğŸ§  delete â†’ safe & rollbackable
ğŸ”¥ truncate â†’ permanent & very fast


##########################################################################################################################################################################################

ğŸ”Ÿ frappe.db.commit - 

used to save (commit) all the database changes made during the current transaction.

- It executes an SQL COMMIT statement.
- Once committed, all previous INSERT, UPDATE, or DELETE actions become permanent.
- Until you commit, those changes exist only temporarily in memory (transaction buffer).

ğŸ§  In simple words â†’ itâ€™s like pressing â€œSaveâ€ after making several database changes.



ğŸ§© When to use:
Normally, Frappe automatically handles commits after requests, jobs, or events.
But you may manually call it when youâ€™re doing custom DB operations in scripts or background jobs that must be saved immediately.


ğŸ§  Syntax :

frappe.db.commit()
Simple meaning: : Save all pending database changes permanently.



âš ï¸ Important Notes:

- After commit(), you cannot rollback those changes.
- If your script fails before commit, changes will be automatically rolled back by Frappe.
- Avoid unnecessary manual commits â€” let Frappe handle it unless youâ€™re doing bulk DB operations or custom scripts.



ğŸ’¡ In short:

- âœ… Saves changes permanently
- ğŸ§  Usually not needed manually
- âš ï¸ Use carefully during custom DB manipulations



##########################################################################################################################################################################################


1ï¸âƒ£1ï¸âƒ£ frappe.db.savepoint
used to create a temporary checkpoint (called a savepoint) within a database transaction.

- Think of it like a â€œmini backup pointâ€ â€” if something goes wrong later, you can roll back only to that point instead of undoing everything.
- Used when you want partial rollback control inside a transaction.

ğŸ§  Simple meaning: ğŸ‘‰ â€œRemember this position in my database changes â€” I might come back here if needed.â€



ğŸ§  Syntax : 

frappe.db.savepoint(save_point_name)
here, save_point_name â†’ any string (identifier for the savepoint)



âš™ï¸ How it works (simple explanation):

- When you call savepoint('point1') â€” Frappe marks the current DB state.

- If later you call frappe.db.rollback('point1'),
  â†’ it will undo all changes done after that savepoint, but keep older ones safe.
  
  
  
  
ğŸ’¡ Tip:

- Savepoints are very useful inside large or complex transactions, where you want to rollback part of your changes without losing everything.
- After committing (frappe.db.commit()), all savepoints are cleared. 


âš ï¸ Important:

- Savepoints only work inside a single transaction.
- They donâ€™t persist once the transaction is committed or rolled back fully.



In short ğŸ§ 

- savepoint() â†’ sets a checkpoint inside your transaction
- rollback('name') â†’ reverts changes done after that checkpoint only


##########################################################################################################################################################################################


1ï¸âƒ£2ï¸âƒ£ frappe.db.rollback
used to undo (revert) all or part of the current database transaction.

- It executes the SQL command ROLLBACK.
- All uncommitted changes (INSERT, UPDATE, DELETE, etc.) made after the last commit or savepoint are discarded.
- Itâ€™s like pressing â€œUndoâ€ for your database actions in that transaction.

ğŸ§  Simple meaning: â€œCancel all recent database changes that arenâ€™t yet committed.â€




ğŸ§  Syntax :

# rollback entire transaction
frappe.db.rollback()

# rollback to a specific savepoint
frappe.db.rollback(save_point="save_point_name")


âš™ï¸ How it works (simple logic):

- If no save_point is given â†’ rolls back entire transaction (all changes since last commit).
- If save_point is given â†’ rolls back only the part after that savepoint, earlier actions remain safe.



âš ï¸ Important Notes / Behaviour:

- Once you rollback, all uncommitted changes are gone â€” not recoverable.

- Frappe automatically runs rollback when:
      - A web request (POST/PUT) throws an error or exception.

- Rollback does not undo:
      - File system changes (like uploaded files)
      - Custom external operations



ğŸ’¡ Tip:

- Use rollback() for safety in scripts when you want to stop and undo halfway.
- Use with savepoint for partial safety instead of losing everything.

ğŸ§  In short summary:

| Command                                 | Action                          | Scope            | Can be Partial? | Undo Filesystem? |
| :-------------------------------------- | :------------------------------ | :--------------- | :-------------- | :--------------- |
| `frappe.db.rollback()`                  | Undo all uncommitted DB changes | Full Transaction | âŒ No            | âŒ No             |
| `frappe.db.rollback(save_point='name')` | Undo from a specific point      | Partial          | âœ… Yes           | âŒ No             |




##########################################################################################################################################################################################


1ï¸âƒ£3ï¸âƒ£ frappe.db.sql
used to execute raw SQL queries directly on the database.

- It gives you full control for complex operations, like multi-table joins or custom reports.
- You can write any SQL (SELECT, INSERT, UPDATE, DELETE, etc.).
- You can also pass parameters safely using the values argument (to prevent SQL injection)

ğŸ§  Simple meaning:  Run your own SQL query directly from Python â€” like writing SQL in MySQL Workbench, but inside Frappe.



ğŸ§  Syntax :

frappe.db.sql(query, values=None, as_dict=False)

| Parameter | Description                                                               |
| --------- | ------------------------------------------------------------------------- |
| `query`   | SQL query string (can be multiline)                                       |
| `values`  | Dictionary or list of parameters to safely inject                         |
| `as_dict` | If `True`, returns results as list of dictionaries; if `False`, as tuples |


âš ï¸ Important Notes / Warnings ğŸš¨

- frappe.db.sql() bypasses all ORM and Frappe permission checks.
- It also skips:
    - Triggers (validate, on_update, etc.)
    - Role-based access controls
    - Field-level restrictions
- So always use it only when ORM methods (like frappe.db.get_list) are not enough.


ğŸ’¡ Best Practices:
âœ… Prefer ORM methods (get_list, get_all, get_value, etc.) whenever possible.
âœ… Use values for variables to prevent SQL injection.
âœ… Use as_dict=True for clean, readable output.


ğŸ§  In short summary:

| Feature              | frappe.db.sql                            |
| :------------------- | :--------------------------------------- |
| Purpose              | Run raw SQL queries                      |
| Bypasses Permissions | âœ… Yes                                   |
| ORM Triggers Run     | âŒ No                                    |
| Output Type          | Tuple (default) or Dict (`as_dict=True`) |
| Use Case             | Complex queries, joins, reports          |



##########################################################################################################################################################################################

1ï¸âƒ£4ï¸âƒ£ frappe.db.multisql
used when your app needs to support multiple database engines (like MariaDB and PostgreSQL).

- It allows you to write both versions of the same SQL query â€” one for MariaDB and one for PostgreSQL â€” and Frappe will automatically run the correct 
  one based on which database your system is using.


ğŸ§  Simple Meaning:
- Use this when a query works differently in MariaDB and PostgreSQL.
- Frappe will choose automatically the correct version of your query.


ğŸ§© Syntax:

frappe.db.multisql({
    "mariadb": "<MariaDB specific query>",
    "postgres": "<PostgreSQL specific query>"
})

--------------------------------------------------------------------

ğŸ’» Example:

frappe.db.multisql({
    "mariadb": "UPDATE `tabStudent` SET status='Active' WHERE age < 20",
    "postgres": 'UPDATE "tabStudent" SET status=\'Active\' WHERE age < 20'
})


ğŸ‘‰ Here both queries do the same thing â€”
they just differ in syntax (MariaDB uses backticks ``, PostgreSQL uses double quotes "").

--------------------------------------------------------------------

âš™ï¸ Real World Use Case:
- Letâ€™s say your custom app will be used by people on both MariaDB (default in ERPNext) and PostgreSQL (new support).
- Some SQL syntax (like quoting table names, date functions, or JSON functions) changes between databases.
- Instead of writing if-else logic â€”
- frappe.db.multisql() will automatically handle it for you.


ğŸ’¡ Best Practice:

- Use this only when your SQL query syntax is database-dependent.
- Otherwise, use frappe.db.sql() â€” it's simpler.
- You can also use Frappe ORM methods (get_list, get_all) to avoid database-specific code altogether.


ğŸ§  Summary Table:

| Feature      | Description                                                 |
| ------------ | ----------------------------------------------------------- |
| Purpose      | Run DB-specific SQL queries (MariaDB/Postgres)              |
| Parameters   | Dict with keys `"mariadb"` and `"postgres"`                 |
| Auto-Selects | Query for current DB engine                                 |
| Use Case     | Cross-database compatibility                                |
| Example      | `frappe.db.multisql({'mariadb': '...', 'postgres': '...'})` |


ğŸª„ In short:
âœ… frappe.db.sql() â†’ one query for one DB
âœ… frappe.db.multisql() â†’ two queries, Frappe chooses based on DB type



##########################################################################################################################################################################################


1ï¸âƒ£5ï¸âƒ£ frappe.db.rename_table
used to rename a table directly at the database level using SQL.

- It changes the table name from the old name to the new name.

ğŸ§  Simple Meaning: Itâ€™s like running RENAME TABLE old_name TO new_name; directly in the database.



ğŸ§© Syntax:
frappe.db.rename_table(old_name, new_name)

--------------------------------------------------------------------

ğŸ’» Example:
frappe.db.rename_table("__internal_cache", "__temporary_cache")
frappe.db.rename_table("todo", "ToDo")

âœ… The first example renames an internal/custom table (__internal_cache â†’ __temporary_cache).
âš ï¸ The second renames the actual DocType table (tabToDo) â€” which can break links and metadata in Frappe, so avoid it unless you really know what youâ€™re doing.

--------------------------------------------------------------------

ğŸš« Important Warning (s):

- Donâ€™t use this for DocType tables â†’ use frappe.rename_doc() instead. That method safely updates all references, links, and metadata.
- frappe.db.rename_table() only changes the database table name, not Frappeâ€™s internal records or DocType names.


ğŸ’¡ Real World Use Case:

- When you have custom/internal tables (like temporary logs or caches) and you want to rename them safely.
- For system-level scripts or migrations â€” not for normal business doctypes.


ğŸ§  Summary Table

| Feature      | Description                                         |
| ------------ | --------------------------------------------------- |
| Purpose      | Rename an SQL table directly                        |
| Syntax       | `frappe.db.rename_table(old_name, new_name)`        |
| Safe for     | Internal or custom tables (`__temp`, `__cache`)     |
| Not Safe for | DocType tables like `tabToDo`, `tabTask`            |
| Alternative  | Use `frappe.rename_doc()` for DocTypes              |
| Example      | `frappe.db.rename_table("__cache", "__temp_cache")` |


ğŸª„ In short:
âœ… Use for internal/custom tables
ğŸš« Donâ€™t use for Doctype tables â†’ use frappe.rename_doc() instead


##########################################################################################################################################################################################


1ï¸âƒ£6ï¸âƒ£ frappe.db.describe

- returns the table structure (schema) of a given DocType.
- It tells you all the columns, data types, and properties inside that table.


ğŸ§  Simple Meaning:
ğŸ‘‰ Itâ€™s like running this SQL: DESC tabDoctypeName; It shows what fields exist in that table.


ğŸ§© Syntax:
frappe.db.describe(doctype)


ğŸ§  Output:
It will return a tuple containing info for each column, such as:
(field_name, data_type, nullable, key, default, extra)

like, 
(
  ('name', 'varchar(140)', 'NO', 'PRI', None, ''),
  ('owner', 'varchar(140)', 'YES', '', None, ''),
  ('creation', 'datetime', 'YES', '', None, '')
)


ğŸ’¡ Use Case:

- To inspect what columns exist in a table.
- Useful for debugging, migrations, or custom SQL queries.



ğŸ§  Summary Table

| Feature    | Description                  |
| ---------- | ---------------------------- |
| Purpose    | Get database table structure |
| Returns    | Tuple containing field info  |
| Works On   | Any DocType                  |
| Similar To | `DESC tabDoctypeName` in SQL |
| Example    | `frappe.db.describe("Task")` |


ğŸª„ In short:
âœ… Returns table structure of a DocType (like SQL DESC)



##########################################################################################################################################################################################




1ï¸âƒ£7ï¸âƒ£ frappe.db.change_column_type
used to change the data type of a column in a DocType table.


- It executes a SQL ALTER TABLE command to modify the columnâ€™s type.
- Useful during migrations or schema updates when a field type needs to be changed (e.g., INT â†’ FLOAT, VARCHAR(100) â†’ TEXT).

ğŸ§  Simple Meaning: 
ğŸ‘‰ Change a columnâ€™s type directly in the database table.



ğŸ§© Syntax:
frappe.db.change_column_type(doctype, column_name, new_type)


doctype â†’ The DocType whose table you want to modify
column_name â†’ The field/column to change
new_type â†’ The new SQL data type (like INT, VARCHAR(200), TEXT, etc.)


--------------------------------------------------------------------

ğŸ’» Example:

# Change 'number' field in Database API to FLOAT

frappe.db.change_column_type('Database API', 'number', 'FLOAT')

print("#"*50)
print("\n"*10)
print("Column 'number' type changed to FLOAT successfully.")
print("\n"*10)
print("#"*50)

--------------------------------------------------------------------


âš ï¸ Important Notes:

- This directly modifies the table structure, so use carefully.
- It bypasses ORM validation â€” Frappe wonâ€™t check or update DocType metadata.
- Changing types may fail if existing data is incompatible with the new type.


ğŸ’¡ Use Case:

- Migrating fields to larger types (VARCHAR â†’ TEXT)
- Converting numbers to decimals for calculations (INT â†’ FLOAT)
- Adjusting database schema without creating a new field


ğŸ§  Summary Table

| Feature   | Description                                               |
| --------- | --------------------------------------------------------- |
| Purpose   | Change the data type of a column                          |
| Syntax    | `frappe.db.change_column_type(doctype, column, new_type)` |
| Works On  | Any DocType table                                         |
| Important | Bypasses ORM, may fail if data incompatible               |
| Example   | Change `number` from INT to FLOAT                         |


ğŸª„ In short:
âœ… Directly changes column type in DB table
âš ï¸ Use with caution â€” ensure data is compatible with new type




##########################################################################################################################################################################################



1ï¸âƒ£8ï¸âƒ£ frappe.db.add_index
used to create a database index on one or more fields of a DocType table.

- Indexes speed up search and query operations on those fields.
- Without indexes, queries on large tables can be slow.
- You can specify custom index names.
- âš ï¸ For TEXT or BLOB fields, you must give a fixed length (field_name(length)) to create an index.


ğŸ§  Simple Meaning:
ğŸ‘‰ Make certain fields searchable faster in the database.


ğŸ§© Syntax:
frappe.db.add_index(doctype, fields, index_name)

doctype â†’ DocType to add the index to
fields â†’ List of fields to index (for TEXT/BLOB fields, add length like "field(100)")
index_name â†’ Optional name of the index

--------------------------------------------------------------------

ğŸ’» Example:


1st
# Add index on 'name1' and 'check' fields in Database API
frappe.db.add_index('Database API', ['name1', 'check'], 'idx_name1_check')

print("#"*50)
print("\n"*10)
print("Index 'idx_name1_check' created successfully on 'Database API'.")
print("\n"*10)
print("#"*50)


2nd.
# Example with TEXT field:

# Add index on first 50 charc of a TEXT field 'description'
frappe.db.add_index('Database API', ['description(50)'], 'idx_description_50')

--------------------------------------------------------------------

âš ï¸ Important Notes:

- Adding an index can increase storage slightly.
- Indexes improve query speed but can slow down insert/update operations on the indexed fields.
- Use indexes on fields that are frequently filtered or sorted in queries.


ğŸ§  Summary Table

| Feature      | Description                                                |
| ------------ | ---------------------------------------------------------- |
| Purpose      | Create a database index on fields                          |
| Syntax       | `frappe.db.add_index(doctype, fields, index_name)`         |
| Works On     | Any DocType table                                          |
| Special Rule | TEXT/BLOB fields need fixed length                         |
| Example      | Index on `['name1','check']` with name `'idx_name1_check'` |


ğŸª„ In short:
âœ… Speeds up queries on specified fields
âš ï¸ Use thoughtfully â€” too many indexes can slow inserts/updates


- Indexes are not new columns. They are database structures that help speed up queries.



##########################################################################################################################################################################################


1ï¸âƒ£9ï¸âƒ£ frappe.db.add_unique
used to create a UNIQUE constraint on one or more fields in a DocType table.

- Ensures that no two records can have the same value(s) for the specified field(s).
- Helps maintain data integrity.
- You can optionally provide a custom constraint name.


ğŸ§  Simple meaning:
ğŸ‘‰ Make one or more fields unique so duplicates are not allowed.


ğŸ§© Syntax :
frappe.db.add_unique(doctype, fields, constraint_name=None)

doctype â†’ DocType whose table you want to enforce uniqueness on
fields â†’ List of field names to make unique
constraint_name â†’ Optional custom name for the unique constraint


--------------------------------------------------------------------

ğŸ’» Example

1. Single field unique constraint

frappe.db.add_unique('Database API', ['name1'])

print("#"*50)
print("\n"*10)
print("Unique constraint added on 'name1' in Database API.")
print("\n"*10)
print("#"*50)


2. Multiple fields unique constraint

frappe.db.add_unique('Database API', ['name1', 'number'], 'unique_name1_number')

print("#"*50)
print("\n"*10)
print("Unique constraint 'unique_name1_number' added on 'name1' and 'number'.")
print("\n"*10)
print("#"*50)

--------------------------------------------------------------------


âš ï¸ Important Notes:

- Existing duplicate records must be removed before adding a unique constraint.
- The database will prevent inserts or updates that violate the constraint.
- Useful for fields like codes, email addresses, or combination of fields that must remain unique.


ğŸ§  Summary Table

| Feature  | Description                                                   |
| -------- | ------------------------------------------------------------- |
| Purpose  | Enforce uniqueness of one or more fields                      |
| Syntax   | `frappe.db.add_unique(doctype, fields, constraint_name=None)` |
| Works On | Any DocType table                                             |
| Optional | Custom constraint name                                        |
| Example  | `add_unique('Database API', ['name1','number'])`              |


ğŸª„ In short:
âœ… Ensures no duplicates for given field(s)
âš ï¸ Clean existing duplicates before applying constraint


--------------------------------------------------------------------

Deep Understand :::::::::

DocType: Student
Fields: roll_number, class, name
You want to make sure no two students in the same class have the same roll number.


| name  | class | roll_number |
| ----- | ----- | ----------- |
| Alice | 10    | 01          |
| Bob   | 10    | 02          |
| Carol | 10    | 01          |


âŒ Problem: Carol has same roll_number as Alice â€” not allowed!



now we do :
frappe.db.add_unique("Student", ["class", "roll_number"], "unique_class_roll")


Frappe generates SQL to add a UNIQUE constraint:
    
    ALTER TABLE `tabStudent`
    ADD CONSTRAINT `unique_class_roll` UNIQUE (`class`, `roll_number`);

now , If anyone tries to insert or update a record with a class + roll_number combination that already exists, the database will reject it.


question : but here you use also class, so i think class also must be unique am i right or not in 
           frappe.db.add_unique("Student", ["class", "roll_number"], "unique_class_roll") 
           means class 10 now not work need to be unique
           
Answer :

âœ… What it really means behind the scenes:

- The combination of class + roll_number must be unique.
- Not each field individually, only the pair together.

valid :

| name  | class | roll_number |                                                  |
| ----- | ----- | ----------- | ------------------------------------------------ |
| Alice | 10    | 01          | âœ… OK                                             |
| Bob   | 10    | 02          | âœ… OK                                             |
| Carol | 11    | 01          | âœ… OK â†’ different class, same roll_number allowed |
| Dave  | 10    | 01          | âŒ Not allowed â†’ same class AND same roll_number  |


Explanation:
- The database checks both fields together: (class, roll_number).
- You can have the same roll_number in different classes â€” thatâ€™s fine.
- You cannot have the same roll_number in the same class â€” thatâ€™s what the unique constraint prevents.


ğŸ’¡ In short:

frappe.db.add_unique("Student", ["class", "roll_number"]) â†’ unique combination
If you want each field individually unique, you would need two separate unique constraints:

frappe.db.add_unique("Student", ["class"], "unique_class")
frappe.db.add_unique("Student", ["roll_number"], "unique_roll")


-------------------------------------------------------------------- 

- constraint_name is not a new field in the table.
- The database creates a UNIQUE constraint internally.
- The constraint has a name (unique_class_roll) so the database can reference it (like for dropping it later).
- It does not add a new column â€” the table columns remain the same (class and roll_number).



Think of it like putting a security label on certain columns:
- Columns: class, roll_number â†’ actual data
- Constraint: unique_class_roll â†’ just a rule attached to these columns that says â€œcannot duplicate this combinationâ€
- No extra data is stored in the table itself.


So in short:

âœ… constraint_name = label for the UNIQUE rule
âŒ Not a new field in the table



##########################################################################################################################################################################################


Database transaction hooks  ::::::

visit the chat(Database API) & read, if you faced any question then learn on that chat with new prompt dont update because it earse it new chat after updatable chat.




##########################################################################################################################################################################################



Database transaction model  :::::: also you can read chat. called Database API


ğŸ“˜ Definition / Purpose:
- Frappe provides a built-in transaction model that automatically handles commits and rollbacks in most cases, so you usually donâ€™t need to manually use SQL COMMIT or ROLLBACK.

- Ensures data consistency
- Reduces risk of leaving partial updates in the database


ğŸ§  Simple Meaning:
ğŸ‘‰ Frappe automatically decides when to commit or rollback your database changes depending on the type of operation (web request, background job, patch, or test).



ğŸ”¹ How it works :


1ï¸âƒ£ Web Requests
- POST / PUT requests â†’ changes committed at end of successful request
- GET requests â†’ do not commit automatically
- Uncaught exceptions â†’ transaction is rolled back
- frappe.call â†’ POST by default

ex.

# Web POST request updates a Task
frappe.get_doc("Task", "TASK0001").update({"status": "Completed"}).save()
# If no exception â†’ commit happens automatically
# If exception â†’ rollback

-------------------------------------------------------------------- 

2ï¸âƒ£ Background / Scheduled Jobs
- Transaction committed after successful job
- Uncaught exception â†’ rollback

ex.

@frappe.whitelist()
def background_task():
    frappe.get_doc("Task", "TASK0001").update({"status": "Completed"}).save()
    # commit happens automatically if no exception

--------------------------------------------------------------------

3ï¸âƒ£ Patches
execute() function commits automatically if successful
Exception â†’ rollback

ex.

def execute():
    frappe.db.set_value("Task", "TASK0001", "status", "Completed")
    # commit happens after patch runs successfully



--------------------------------------------------------------------

4ï¸âƒ£ Unit Tests
- Transaction committed after one test module finishes
- Committed again after all tests finish
- Exception â†’ test runner exits â†’ rollback

--------------------------------------------------------------------

âš ï¸ Important Notes 
- If you catch exceptions manually, Frappe cannot detect failures, so you are responsible for manually rolling back:

try:
    frappe.get_doc("Task", "TASK0001").delete()
except Exception as e:
    frappe.db.rollback()  # must rollback manually


Frappeâ€™s automatic transaction handling only works for uncaught exceptions.



ğŸª„ In short:
âœ… Frappe automatically commits or rolls back based on operation type
âœ… POST/PUT web requests, background jobs, patches, and tests â†’ auto transaction handling
âš ï¸ If you catch exceptions, you must rollback manually














